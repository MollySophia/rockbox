/***************************************************************************
 *             __________               __   ___.
 *   Open      \______   \ ____   ____ |  | _\_ |__   _______  ___
 *   Source     |       _//  _ \_/ ___\|  |/ /| __ \ /  _ \  \/  /
 *   Jukebox    |    |   (  <_> )  \___|    < | \_\ (  <_> > <  <
 *   Firmware   |____|_  /\____/ \___  >__|_ \|___  /\____/__/\_ \
 *                     \/            \/     \/    \/            \/
 * This file was automatically generated by headergen, DO NOT EDIT it.
 * headergen version: 3.0.0
 *
 * Copyright (C) 2015 by the authors
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 * KIND, either express or implied.
 *
 ****************************************************************************/
#ifndef __HEADERGEN_MACRO_H__
#define __HEADERGEN_MACRO_H__

#define __VAR_OR1(prefix, suffix) \
    (prefix##suffix)
#define __VAR_OR2(pre, s1, s2) \
    (__VAR_OR1(pre, s1) | __VAR_OR1(pre, s2))
#define __VAR_OR3(pre, s1, s2, s3) \
    (__VAR_OR1(pre, s1) | __VAR_OR2(pre, s2, s3))
#define __VAR_OR4(pre, s1, s2, s3, s4) \
    (__VAR_OR2(pre, s1, s2) | __VAR_OR2(pre, s3, s4))
#define __VAR_OR5(pre, s1, s2, s3, s4, s5) \
    (__VAR_OR2(pre, s1, s2) | __VAR_OR3(pre, s3, s4, s5))
#define __VAR_OR6(pre, s1, s2, s3, s4, s5, s6) \
    (__VAR_OR3(pre, s1, s2, s3) | __VAR_OR3(pre, s4, s5, s6))
#define __VAR_OR7(pre, s1, s2, s3, s4, s5, s6, s7) \
    (__VAR_OR3(pre, s1, s2, s3) | __VAR_OR4(pre, s4, s5, s6, s7))
#define __VAR_OR8(pre, s1, s2, s3, s4, s5, s6, s7, s8) \
    (__VAR_OR4(pre, s1, s2, s3, s4) | __VAR_OR4(pre, s5, s6, s7, s8))
#define __VAR_OR9(pre, s1, s2, s3, s4, s5, s6, s7, s8, s9) \
    (__VAR_OR4(pre, s1, s2, s3, s4) | __VAR_OR5(pre, s5, s6, s7, s8, s9))
#define __VAR_OR10(pre, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10) \
    (__VAR_OR5(pre, s1, s2, s3, s4, s5) | __VAR_OR5(pre, s6, s7, s8, s9, s10))
#define __VAR_OR11(pre, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11) \
    (__VAR_OR5(pre, s1, s2, s3, s4, s5) | __VAR_OR6(pre, s6, s7, s8, s9, s10, s11))
#define __VAR_OR12(pre, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12) \
    (__VAR_OR6(pre, s1, s2, s3, s4, s5, s6) | __VAR_OR6(pre, s7, s8, s9, s10, s11, s12))
#define __VAR_OR13(pre, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13) \
    (__VAR_OR6(pre, s1, s2, s3, s4, s5, s6) | __VAR_OR7(pre, s7, s8, s9, s10, s11, s12, s13))

#define __VAR_NARGS(...) __VAR_NARGS_(__VA_ARGS__, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
#define __VAR_NARGS_(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, N, ...) N

#define __VAR_EXPAND(macro, prefix, ...) __VAR_EXPAND_(macro, __VAR_NARGS(__VA_ARGS__), prefix, __VA_ARGS__)
#define __VAR_EXPAND_(macro, cnt, prefix, ...) __VAR_EXPAND__(macro, cnt, prefix, __VA_ARGS__)
#define __VAR_EXPAND__(macro, cnt, prefix, ...) __VAR_EXPAND___(macro##cnt, prefix, __VA_ARGS__)
#define __VAR_EXPAND___(macro, prefix, ...) macro(prefix, __VA_ARGS__)

#define HWIO_8_RO(op, name, ...)        HWIO_8_RO_##op(name, __VA_ARGS__)
#define HWIO_8_RO_RD(name, ...)         (*(const volatile uint8_t *)(HWA_##name))
#define HWIO_8_RO_WR(name, val)         _Static_assert(0, #name " is read-only")
#define HWIO_8_RO_RMW(name, vand, vor)  _Static_assert(0, #name " is read-only")
#define HWIO_8_RO_VAR(name, ...)        (*(const volatile uint8_t *)(HWA_##name))

#define HWIO_16_RO(op, name, ...)       HWIO_16_RO_##op(name, __VA_ARGS__)
#define HWIO_16_RO_RD(name, ...)        (*(const volatile uint16_t *)(HWA_##name))
#define HWIO_16_RO_WR(name, val)        _Static_assert(0, #name " is read-only")
#define HWIO_16_RO_RMW(name, vand, vor) _Static_assert(0, #name " is read-only")
#define HWIO_16_RO_VAR(name, ...)       (*(const volatile uint16_t *)(HWA_##name))

#define HWIO_32_RO(op, name, ...)       HWIO_32_RO_##op(name, __VA_ARGS__)
#define HWIO_32_RO_RD(name, ...)        (*(const volatile uint32_t *)(HWA_##name))
#define HWIO_32_RO_WR(name, val)        _Static_assert(0, #name " is read-only")
#define HWIO_32_RO_RMW(name, vand, vor) _Static_assert(0, #name " is read-only")
#define HWIO_32_RO_VAR(name, ...)       (*(const volatile uint32_t *)(HWA_##name))

#define HWIO_8_RW(op, name, ...)        HWIO_8_RW_##op(name, __VA_ARGS__)
#define HWIO_8_RW_RD(name, ...)         (*(volatile uint8_t *)(HWA_##name))
#define HWIO_8_RW_WR(name, val)         (*(volatile uint8_t *)(HWA_##name)) = (val)
#define HWIO_8_RW_RMW(name, vand, vor)  HWIO_8_RW_WR(name, (HWIO_8_RW_RD(name) & (vand)) | (vor))
#define HWIO_8_RW_VAR(name, ...)        (*(volatile uint8_t *)(HWA_##name))

#define HWIO_16_RW(op, name, ...)       HWIO_16_RW_##op(name, __VA_ARGS__)
#define HWIO_16_RW_RD(name, ...)        (*(volatile uint16_t *)(HWA_##name))
#define HWIO_16_RW_WR(name, val)        (*(volatile uint16_t *)(HWA_##name)) = (val)
#define HWIO_16_RW_RMW(name, vand, vor) HWIO_16_RW_WR(name, (HWIO_16_RW_RD(name) & (vand)) | (vor))
#define HWIO_16_RW_VAR(name, ...)       (*(volatile uint16_t *)(HWA_##name))

#define HWIO_32_RW(op, name, ...)       HWIO_32_RW_##op(name, __VA_ARGS__)
#define HWIO_32_RW_RD(name, ...)        (*(volatile uint32_t *)(HWA_##name))
#define HWIO_32_RW_WR(name, val)        (*(volatile uint32_t *)(HWA_##name)) = (val)
#define HWIO_32_RW_RMW(name, vand, vor) HWIO_32_RW_WR(name, (HWIO_32_RW_RD(name) & (vand)) | (vor))
#define HWIO_32_RW_VAR(name, ...)       (*(volatile uint32_t *)(HWA_##name))

#define HWIO_8_WO(op, name, ...)        HWIO_8_WO_##op(name, __VA_ARGS__)
#define HWIO_8_WO_RD(name, ...)         ({_Static_assert(0, #name " is write-only"); 0;})
#define HWIO_8_WO_WR(name, val)         (*(volatile uint8_t *)(HWA_##name)) = (val)
#define HWIO_8_WO_RMW(name, vand, vor)  HWIO_8_WO_WR(name, vor)
#define HWIO_8_WO_VAR(name, ...)        (*(volatile uint8_t *)(HWA_##name))

#define HWIO_16_WO(op, name, ...)       HWIO_16_WO_##op(name, __VA_ARGS__)
#define HWIO_16_WO_RD(name, ...)        ({_Static_assert(0, #name " is write-only"); 0;})
#define HWIO_16_WO_WR(name, val)        (*(volatile uint16_t *)(HWA_##name)) = (val)
#define HWIO_16_WO_RMW(name, vand, vor) HWIO_16_WO_WR(name, vor)
#define HWIO_16_WO_VAR(name, ...)       (*(volatile uint16_t *)(HWA_##name))

#define HWIO_32_WO(op, name, ...)       HWIO_32_WO_##op(name, __VA_ARGS__)
#define HWIO_32_WO_RD(name, ...)        ({_Static_assert(0, #name " is write-only"); 0;})
#define HWIO_32_WO_WR(name, val)        (*(volatile uint32_t *)(HWA_##name)) = (val)
#define HWIO_32_WO_RMW(name, vand, vor) HWIO_32_WO_WR(name, vor)
#define HWIO_32_WO_VAR(name, ...)       (*(volatile uint32_t *)(HWA_##name))


/** __REG_VARIANT
 *
 * usage: __REG_VARIANT(register, variant_prefix, variant_postfix)
 *
 * effect: expands to register variant given as argument
 * note: internal usage
 * note: register must be fully qualified if indexed
 *
 * example: __REG_VARIANT(ICOLL_CTRL, , _SET)
 * example: __REG_VARIANT(ICOLL_ENABLE(3), , _CLR)
 */
#define __REG_VARIANT(name, varp, vars) __REG_VARIANT_(HWN_##name, HWI_##name, varp, vars)
#define __REG_VARIANT_(...) __REG_VARIANT__(__VA_ARGS__)
#define __REG_VARIANT__(name, index, varp, vars) varp##name##vars index

/** BF_OR
 *
 * usage: BF_OR(register, f1(v1), f2(v2), ...)
 *
 * effect: expands to the register value where each field fi has value vi.
 *         Informally: reg_f1(v1) | reg_f2(v2) | ...
 * note: enumerated values for fields can be obtained by using the syntax:
 *          f1_V(name)
 *
 * example: BF_OR(ICOLL_CTRL, SFTRST(1), CLKGATE(0), TZ_LOCK_V(UNLOCKED))
 */
#define BF_OR(reg, ...) __VAR_EXPAND(__VAR_OR, BF_##reg##_, __VA_ARGS__)

/** __BFM_OR
 *
 * usage: __BFM_OR(register, f1(v1), f2(v2), ...)
 *
 * effect: expands to the register value where each field fi has maximum value (vi is ignored).
 * note: internal usage
 *
 * example: __BFM_OR(ICOLL_CTRL, SFTRST(1), CLKGATE(0), TZ_LOCK_V(UNLOCKED))
 */
#define __BFM_OR(reg, ...) __VAR_EXPAND(__VAR_OR, BFM_##reg##_, __VA_ARGS__)

/** BM_OR
 *
 * usage: BM_OR(register, f1, f2, ...)
 *
 * effect: expands to the register value where each field fi is set to its maximum value.
 *         Informally: reg_f1_mask | reg_f2_mask | ...
 *
 * example: BM_OR(ICOLL_CTRL, SFTRST, CLKGATE)
 */
#define BM_OR(reg, ...) __VAR_EXPAND(__VAR_OR, BM_##reg##_, __VA_ARGS__)


/** REG_RD
 *
 * usage: REG_RD(register)
 *
 * effect: read a register and return its value
 * note: register must be fully qualified if indexed
 *
 * example: REG_RD(ICOLL_STATUS)
 *          REG_RD(ICOLL_ENABLE(42))
 */
#define REG_RD(name) HWT_##name(RD, name)

/** BF_RDX
 *
 * usage: BF_RDX(value, register, field)
 *
 * effect: given a register value, return the value of a particular field
 * note: this macro does NOT read any register
 *
 * example: BF_RDX(0xc0000000, ICOLL_CTRL, SFTRST)
 *          BF_RDX(0x46ff, ICOLL_ENABLE, CPU0_PRIO)
 */
#define BF_RDX(val, name, field) (((val) & BM_##name##_##field) >> BP_##name##_##field)

/** BF_RD
 *
 * usage: BF_RD(register, field)
 *
 * effect: read a register and return the value of a particular field
 * note: register must be fully qualified if indexed
 *
 * example: BF_RD(ICOLL_CTRL, SFTRST)
 *          BF_RD(ICOLL_ENABLE(3), CPU0_PRIO)
 */
#define BF_RD(name, field) BF_RD_(REG_RD(name), HWN_##name, field)
#define BF_RD_(...) BF_RDX(__VA_ARGS__)

/** REG_WR
 *
 * usage: REG_WR(register, value)
 *
 * effect: write a register
 * note: register must be fully qualified if indexed
 *
 * example: REG_WR(ICOLL_CTRL, 0x42)
 *          REG_WR(ICOLL_ENABLE_SET(3), 0x37)
 */
#define REG_WR(name, val) HWT_##name(WR, name, val)

/** BF_WR
 *
 * usage: BF_WR(register, f1(v1), f2(v2), ...)
 *
 * effect: change the register value so that field fi has value vi
 * note: register must be fully qualified if indexed
 * note: this macro may perform a read-modify-write
 *
 * example: BF_WR(ICOLL_CTRL, SFTRST(1), CLKGATE(0), TZ_LOCK_V(UNLOCKED))
 *          BF_WR(ICOLL_ENABLE(3), CPU0_PRIO(1), CPU0_TYPE_V(FIQ))
 */
#define BF_WR(name, ...) BF_WR_(name, HWN_##name, __VA_ARGS__)
#define BF_WR_(name, name2, ...) HWT_##name(RMW, name, ~__BFM_OR(name2, __VA_ARGS__), BF_OR(name2, __VA_ARGS__))

/** BF_WR_ALL
 *
 * usage: BF_WR_ALL(register, f1(v1), f2(v2), ...)
 *
 * effect: change the register value so that field fi has value vi and other fields have value zero
 *         thus this macro is equivalent to:
 *         REG_WR(register, BF_OR(register, f1(v1), ...))
 * note: register must be fully qualified if indexed
 * note: this macro will overwrite the register (it is NOT a read-modify-write)
 *
 * example: BF_WR_ALL(ICOLL_CTRL, SFTRST(1), CLKGATE(0), TZ_LOCK_V(UNLOCKED))
 *          BF_WR_ALL(ICOLL_ENABLE(3), CPU0_PRIO(1), CPU0_TYPE_V(FIQ))
 */
#define BF_WR_ALL(name, ...) BF_WR_ALL_(name, HWN_##name, __VA_ARGS__)
#define BF_WR_ALL_(name, name2, ...) HWT_##name(WR, name, BF_OR(name2, __VA_ARGS__))

/** BF_WRX
 *
 * usage: BF_WRX(var, register, f1(v1), f2(v2), ...)
 *
 * effect: change the variable value so that field fi has value vi
 * note: this macro will perform a read-modify-write
 *
 * example: BF_WRX(var, ICOLL_CTRL, SFTRST(1), CLKGATE(0), TZ_LOCK_V(UNLOCKED))
 *          BF_WRX(var, ICOLL_ENABLE, CPU0_PRIO(1), CPU0_TYPE_V(FIQ))
 */
#define BF_WRX(var, name, ...) (var) = BF_OR(name, __VA_ARGS__) | (~__BFM_OR(name, __VA_ARGS__) & (var))

/** BF_SET
 *
 * usage: BF_SET(register, f1, f2, ...)
 *
 * effect: change the register value so that field fi has maximum value
 * IMPORTANT: this macro performs a write to the set variant of the register
 * note: register must be fully qualified if indexed
 *
 * example: BF_SET(ICOLL_CTRL, SFTRST, CLKGATE)
 *          BF_SET(ICOLL_ENABLE(3), CPU0_PRIO, CPU0_TYPE)
 */
#define BF_SET(name, ...) BF_SET_(__REG_VARIANT(name, , _SET), HWN_##name, __VA_ARGS__)
#define BF_SET_(name, name2, ...) REG_WR(name, BM_OR(name2, __VA_ARGS__))

/** BF_CLR
 *
 * usage: BF_CLR(register, f1, f2, ...)
 *
 * effect: change the register value so that field fi has value zero
 * IMPORTANT: this macro performs a write to the clr variant of the register
 * note: register must be fully qualified if indexed
 *
 * example: BF_CLR(ICOLL_CTRL, SFTRST, CLKGATE)
 *          BF_CLR(ICOLL_ENABLE(3), CPU0_PRIO, CPU0_TYPE)
 */
#define BF_CLR(name, ...) BF_CLR_(__REG_VARIANT(name, , _CLR), HWN_##name, __VA_ARGS__)
#define BF_CLR_(name, name2, ...) REG_WR(name, BM_OR(name2, __VA_ARGS__))

/** REG_CS
 *
 * usage: REG_CS(register, clear_value, set_value)
 *
 * effect: clear some bits using set variant and then set some using set variant
 * note: register must be fully qualified if indexed
 *
 * example: REG_CS(ICOLL_CTRL, 0xff, 0x42)
 *          REG_CS(ICOLL_ENABLE(3), 0xff, 0x37)
 */
#define REG_CS(name, cval, sval) REG_CS_(__REG_VARIANT(name, , _CLR), __REG_VARIANT(name, , _SET), cval, sval)
#define REG_CS_(cname, sname, cval, sval) do { REG_WR(cname, cval); REG_WR(sname, sval); } while(0)

/** BF_CS
 *
 * usage: BF_CS(register, f1(v1), f2(v2), ...)
 *
 * effect: change the register value so that field fi has value vi using clr and set variants
 * note: register must be fully qualified if indexed
 * note: this macro will NOT perform a read-modify-write and is thus safer
 * IMPORTANT: this macro will set some fields to 0 temporarily, make sure this is acceptable
 *
 * example: BF_CS(ICOLL_CTRL, SFTRST(1), CLKGATE(0), TZ_LOCK_V(UNLOCKED))
 *          BF_CS(ICOLL_ENABLE(3), CPU0_PRIO(1), CPU0_TYPE_V(FIQ))
 */
#define BF_CS(name, ...) BF_CS_(name, HWN_##name, __VA_ARGS__)
#define BF_CS_(name, name2, ...) REG_CS(name, __BFM_OR(name2, __VA_ARGS__), BF_OR(name2, __VA_ARGS__))

/** HW
 *
 * usage: HW(register)
 *
 * effect: return a variable-like expression that can be read/written
 * note: register must be fully qualified if indexed
 * note: read-only registers will yield a constant expression
 *
 * example: unsigned x = HW(ICOLL_STATUS)
 *          unsigned x = HW(ICOLL_ENABLE(42))
 *          HW(ICOLL_ENABLE(42)) = 64
 */
#define HW(name) HWT_##name(VAR, name)


#endif /* __HEADERGEN_MACRO_H__*/
